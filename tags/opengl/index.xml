<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Opengl on Halogenica</title>
    <link>https://halogenica.github.io/tags/opengl/</link>
    <description>Recent content in Opengl on Halogenica</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>mike@halogenica.net (Michael Romero)</managingEditor>
    <webMaster>mike@halogenica.net (Michael Romero)</webMaster>
    <lastBuildDate>Wed, 14 Jan 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://halogenica.github.io/tags/opengl/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Fez Viewer</title>
      <link>https://halogenica.github.io/tools/fez-viewer/</link>
      <pubDate>Wed, 14 Jan 2015 00:00:00 +0000</pubDate>
      <author>mike@halogenica.net (Michael Romero)</author>
      <guid>https://halogenica.github.io/tools/fez-viewer/</guid>
      <description>&lt;p&gt;Fez is one of my favorite games of all time. I wanted to do a bit of a tribute to the game as a personal project (I was originally hoping to make some papercraft or 3D printing). To help get a better view of the game, I was looking for a way to visualize the levels.&lt;/p&gt;

&lt;video loop autoplay autobuffer muted playsinline&gt;
    &lt;source src=&#34;https://halogenica.github.io/img/tools/fez-viewer/fox.mp4&#34;&gt;
&lt;/video&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Sharing Resources Between DirectX and OpenGL</title>
      <link>https://halogenica.github.io/graphics/sharing-resources-between-directx-and-opengl/</link>
      <pubDate>Thu, 13 Mar 2014 00:00:00 +0000</pubDate>
      <author>mike@halogenica.net (Michael Romero)</author>
      <guid>https://halogenica.github.io/graphics/sharing-resources-between-directx-and-opengl/</guid>
      <description>&lt;link rel=&#34;stylesheet&#34; href=&#34;https://halogenica.github.io/css/hugo-easy-gallery.css&#34; /&gt;
&lt;div class=&#34;box&#34; &gt;
  &lt;figure  itemprop=&#34;associatedMedia&#34; itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;https://halogenica.github.io/img/graphics/sharing-resources-between-directx-and-opengl/Shared_Resources.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;https://halogenica.github.io/img/graphics/sharing-resources-between-directx-and-opengl/Shared_Resources.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;I&amp;rsquo;ve recently had a need to simultaneously render using both DirectX and OpenGL. There are a number of reasons why this is useful, particularly in tools where you may wish to compare multiple rendering engines simultaneously. With this technique it is also possible to efficiently perform some rendering operations on one API to a render target, and switch to the other API to continue rendering to that render target. It can also be used to perform all rendering in a specific API, while presenting that final render target using another API. Providing direct access to textures and render targets in graphics memory regardless of API has the potential of efficiently pipelining surfaces through multiple discrete renderers.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://halogenica.github.io/bin/graphics/sharing-resources-between-directx-and-opengl/WGL_NV_DX_interop_demo.zip&#34;&gt;WGL_NV_DX_interop_demo.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Signed Distance Fields – Part 1</title>
      <link>https://halogenica.github.io/graphics/signed-distance-fields/</link>
      <pubDate>Fri, 16 Nov 2012 00:00:00 +0000</pubDate>
      <author>mike@halogenica.net (Michael Romero)</author>
      <guid>https://halogenica.github.io/graphics/signed-distance-fields/</guid>
      <description>&lt;p&gt;So there is this cool technique that had gained significant popularity in the demoscene called &amp;ldquo;Signed Distance Fields&amp;rdquo;. There&amp;rsquo;s a truly excellent presentation by iq of rgba (Iñigo Quilez) posted on his website &lt;a href=&#34;http://www.iquilezles.org/www/material/nvscene2008/nvscene2008.htm&#34;&gt;http://www.iquilezles.org&lt;/a&gt; which he presented at nvscene back in 2008 called &amp;ldquo;Rendering Worlds with Two Triangles&amp;rdquo;. I wanted to play around with some GLSL and thought this would be a really interesting algorithm to take a look at. You can see some of the power of these types of functions in a presentation that smash of fairlight (Matt Swaboda) gave at GDC earlier this year &lt;a href=&#34;http://directtovideo.wordpress.com/2012/03/15/get-my-slides-from-gdc2012/&#34;&gt;http://directtovideo.wordpress.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>First Graphics Project</title>
      <link>https://halogenica.github.io/graphics/first-graphics-project/</link>
      <pubDate>Fri, 14 Dec 2007 00:00:00 +0000</pubDate>
      <author>mike@halogenica.net (Michael Romero)</author>
      <guid>https://halogenica.github.io/graphics/first-graphics-project/</guid>
      <description>&lt;p&gt;My very first graphics project. It&amp;rsquo;s written in C, and uses old fixed-function &lt;a href=&#34;http://www.opengl.org/&#34;&gt;OpenGL&lt;/a&gt; and &lt;a href=&#34;http://www.opengl.org/resources/libraries/glut/&#34;&gt;GLUT&lt;/a&gt;. The code is pretty sloppy as most first attempts go. There are a few interactive elements to this project, with the box spreading apart and interesting use of blending. As the transparent surfaces occlude other geometry, the geometry &amp;ldquo;disappears&amp;rdquo; and shapes are revealed inside the formerly opaque geometry.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>