<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Graphics on Halogenica</title>
    <link>https://romero.dev/tags/graphics/</link>
    <description>Recent content in Graphics on Halogenica</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>mike@halogenica.net (Michael Romero)</managingEditor>
    <webMaster>mike@halogenica.net (Michael Romero)</webMaster>
    <lastBuildDate>Wed, 14 Jan 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://romero.dev/tags/graphics/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Fez Viewer</title>
      <link>https://romero.dev/tools/fez-viewer/</link>
      <pubDate>Wed, 14 Jan 2015 00:00:00 +0000</pubDate>
      <author>mike@halogenica.net (Michael Romero)</author>
      <guid>https://romero.dev/tools/fez-viewer/</guid>
      <description>&lt;p&gt;Fez Viewer is a tool that can load the models and levels from Fez, and allow you to freely inspect and fly through them. It currently supports loading individual art objects, animation sets, and even entire levels.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Sharing Resources Between DirectX and OpenGL</title>
      <link>https://romero.dev/graphics/sharing-resources-between-directx-and-opengl/</link>
      <pubDate>Thu, 13 Mar 2014 00:00:00 +0000</pubDate>
      <author>mike@halogenica.net (Michael Romero)</author>
      <guid>https://romero.dev/graphics/sharing-resources-between-directx-and-opengl/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve recently had a need to simultaneously render using both DirectX and OpenGL. With this technique it is possible to efficiently perform some rendering operations within one API for part of an image, and switch to the other API for another part of the image. It can also be used to perform all rendering in a specific API, while presenting that final render target using another API. Providing direct access to graphics memory between APIs allows efficient and optimal sharing.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Signed Distance Fields – Part 1</title>
      <link>https://romero.dev/graphics/signed-distance-fields/</link>
      <pubDate>Fri, 16 Nov 2012 00:00:00 +0000</pubDate>
      <author>mike@halogenica.net (Michael Romero)</author>
      <guid>https://romero.dev/graphics/signed-distance-fields/</guid>
      <description>&lt;p&gt;Signed Distance Fields, when used in computer graphics, is a way of mathematically defining a scene, which can be both greatly compressed, and scale to any resolution. There&amp;rsquo;s a truly excellent presentation by iq of rgba (Iñigo Quilez) posted on his website &lt;a href=&#34;http://www.iquilezles.org/www/material/nvscene2008/nvscene2008.htm&#34;&gt;http://www.iquilezles.org&lt;/a&gt; which he presented at nvscene back in 2008 called &amp;ldquo;Rendering Worlds with Two Triangles&amp;rdquo;. Other powerful examples were presented by smash of fairlight (Matt Swaboda) at GDC earlier this year &lt;a href=&#34;http://directtovideo.wordpress.com/2012/03/15/get-my-slides-from-gdc2012/&#34;&gt;http://directtovideo.wordpress.com&lt;/a&gt;. This is my first expermientation with this rendering technique.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Particle System</title>
      <link>https://romero.dev/graphics/particle-system/</link>
      <pubDate>Wed, 22 Dec 2010 00:00:00 +0000</pubDate>
      <author>mike@halogenica.net (Michael Romero)</author>
      <guid>https://romero.dev/graphics/particle-system/</guid>
      <description>&lt;p&gt;I saw a video online recently of several cubes flying into the scene and stacking up to form a larger cube. I thought it was a pretty simple yet powerful effect. The effect was achieved using Particle Flow, so the movement of the particles are entirely animated and not in real time. After seeing this, I immediately wanted to try it, but with a more general solution. So, off I went to write a physics system for my particle engine.&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/PXYOYEgjDXQ&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Volume Rendering using GPGPU</title>
      <link>https://romero.dev/graphics/volume-rendering-using-gpgpu/</link>
      <pubDate>Mon, 15 Jun 2009 00:00:00 +0000</pubDate>
      <author>mike@halogenica.net (Michael Romero)</author>
      <guid>https://romero.dev/graphics/volume-rendering-using-gpgpu/</guid>
      <description>&lt;p&gt;Traditional 3D computer graphics focus on rendering the exterior of objects. Volume rendering is a technique used to visualize information corresponding to the interior of an object, commonly used in medical imaging and other fields. Visualization of such data may be accomplished by ray casting; similar to ray tracing. Rendering each pixel can be done in parallel, so massively parallel architectures like GPGPU can dramatically speed up rendering.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Volume Rendering on the PSP</title>
      <link>https://romero.dev/graphics/volume-rendering-on-the-psp/</link>
      <pubDate>Sun, 15 Feb 2009 00:00:00 +0000</pubDate>
      <author>mike@halogenica.net (Michael Romero)</author>
      <guid>https://romero.dev/graphics/volume-rendering-on-the-psp/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve long been active in PSP development and decided to have some fun with graphics on the PSP. I asked my university to order two PSP dev systems and I got to work porting my ray tracer to the PSP. As a team effort with three other graphics enthusiasts, we decided to accelerate hypertexturing on the PSP using the VFPU. We ended up with a ray tracer, hypertexturer, and volume ray caster working on the PSP capable of displaying a 64x64x64 voxel volume.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Hypertexturing</title>
      <link>https://romero.dev/graphics/hypertexturing/</link>
      <pubDate>Mon, 19 Jan 2009 00:00:00 +0000</pubDate>
      <author>mike@halogenica.net (Michael Romero)</author>
      <guid>https://romero.dev/graphics/hypertexturing/</guid>
      <description>&lt;p&gt;This code is branched from the Ray Tracer code, with the perlin noise function added and the hit function and normal calculations for the volume of noise/density.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ray Tracer</title>
      <link>https://romero.dev/graphics/ray-tracer/</link>
      <pubDate>Mon, 15 Dec 2008 00:00:00 +0000</pubDate>
      <author>mike@halogenica.net (Michael Romero)</author>
      <guid>https://romero.dev/graphics/ray-tracer/</guid>
      <description>&lt;p&gt;This was my first ray tracer, implemented on the CPU using OpenGL and &lt;a href=&#34;http://www.opengl.org/resources/libraries/glut/&#34;&gt;GLUT&lt;/a&gt; to present to the screen, and coded in &lt;a href=&#34;http://www.bloodshed.net/devcpp.html&#34;&gt;Dev-C++&lt;/a&gt;. It is largely inspired by the ray tracer used in the book &lt;a href=&#34;http://www.raytracegroundup.com/&#34;&gt;Ray Tracing from the Ground Up&lt;/a&gt;, an excellent and highly recommended book on ray tracing by Kevin Suffern.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>First Graphics Project</title>
      <link>https://romero.dev/graphics/first-graphics-project/</link>
      <pubDate>Fri, 14 Dec 2007 00:00:00 +0000</pubDate>
      <author>mike@halogenica.net (Michael Romero)</author>
      <guid>https://romero.dev/graphics/first-graphics-project/</guid>
      <description>&lt;p&gt;My very first graphics project. It&amp;rsquo;s written in C, and uses old fixed-function &lt;a href=&#34;http://www.opengl.org/&#34;&gt;OpenGL&lt;/a&gt; and &lt;a href=&#34;http://www.opengl.org/resources/libraries/glut/&#34;&gt;GLUT&lt;/a&gt;. The code is pretty sloppy as most first attempts go. There are a few interactive elements to this project, with the box spreading apart and interesting use of blending. As the transparent surfaces occlude other geometry, the geometry &amp;ldquo;disappears&amp;rdquo; and shapes are revealed inside the formerly opaque geometry.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>