<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Sharing Resources Between DirectX and OpenGL</title>
  <meta property="og:title" content="Sharing Resources Between DirectX and OpenGL" />
  <meta name="twitter:title" content="Sharing Resources Between DirectX and OpenGL" />
  <meta name="description" content="

  
    
      
    
    
  


I&rsquo;ve recently had a need to simultaneously render using both DirectX and OpenGL. There are a number of reasons why this is useful, particularly in tools where you may wish to compare multiple rendering engines simultaneously. With this technique it is also possible to efficiently perform some rendering operations on one API to a render target, and switch to the other API to continue rendering to that render target. It can also be used to perform all rendering in a specific API, while presenting that final render target using another API. Providing direct access to textures and render targets in graphics memory regardless of API has the potential of efficiently pipelining surfaces through multiple discrete renderers.

WGL_NV_DX_interop_demo.zip

">
  <meta property="og:description" content="

  
    
      
    
    
  


I&rsquo;ve recently had a need to simultaneously render using both DirectX and OpenGL. There are a number of reasons why this is useful, particularly in tools where you may wish to compare multiple rendering engines simultaneously. With this technique it is also possible to efficiently perform some rendering operations on one API to a render target, and switch to the other API to continue rendering to that render target. It can also be used to perform all rendering in a specific API, while presenting that final render target using another API. Providing direct access to textures and render targets in graphics memory regardless of API has the potential of efficiently pipelining surfaces through multiple discrete renderers.

WGL_NV_DX_interop_demo.zip

">
  <meta name="twitter:description" content="

  
    
      
    
    
  


I&rsquo;ve recently had a need to simultaneously render using both DirectX and OpenGL. There are a number of reasons why this is useful, particularly in tools where you …">
  <meta name="author" content="Michael Romero"/>
  <link href='https://halogenica.github.io/img/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@halogenica" />
  <meta name="twitter:creator" content="@halogenica" />
  <meta property="og:url" content="https://halogenica.github.io/graphics/sharing-resources-between-directx-and-opengl/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Halogenica" />

  <meta name="generator" content="Hugo 0.48" />
  <link rel="canonical" href="https://halogenica.github.io/graphics/sharing-resources-between-directx-and-opengl/" />
  <link rel="alternate" href="https://halogenica.github.io/index.xml" type="application/rss+xml" title="Halogenica">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" integrity="sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="https://halogenica.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://halogenica.github.io/css/highlight.min.css" /><link rel="stylesheet" href="https://halogenica.github.io/css/codeblock.css" />




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">



<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

</head>

  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://halogenica.github.io">Halogenica</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="Games" href="/games/">Games</a>
            </li>
          
        
          
            <li>
              <a title="Graphics" href="/graphics/">Graphics</a>
            </li>
          
        
          
            <li>
              <a title="Tools" href="/tools/">Tools</a>
            </li>
          
        
          
            <li>
              <a title="Software" href="/software/">Software</a>
            </li>
          
        
          
            <li>
              <a title="Hardware" href="/hardware/">Hardware</a>
            </li>
          
        
          
            <li>
              <a title="Tags" href="/tags">Tags</a>
            </li>
          
        
          
            <li>
              <a title="About" href="/about">About</a>
            </li>
          
        

        

        
      </ul>
    </div>

    

  </div>
</nav>




    
  
  
  






  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              
                <h1>Sharing Resources Between DirectX and OpenGL</h1>
              
              
              
              
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp;Posted on March 13, 2014
  
  
  
</span>


              
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        <link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/img/graphics/sharing-resources-between-directx-and-opengl/Shared_Resources.png" />
    </div>
    <a href="/img/graphics/sharing-resources-between-directx-and-opengl/Shared_Resources.png" itemprop="contentUrl"></a>
  </figure>
</div>

<p>I&rsquo;ve recently had a need to simultaneously render using both DirectX and OpenGL. There are a number of reasons why this is useful, particularly in tools where you may wish to compare multiple rendering engines simultaneously. With this technique it is also possible to efficiently perform some rendering operations on one API to a render target, and switch to the other API to continue rendering to that render target. It can also be used to perform all rendering in a specific API, while presenting that final render target using another API. Providing direct access to textures and render targets in graphics memory regardless of API has the potential of efficiently pipelining surfaces through multiple discrete renderers.</p>

<p><a href="/bin/graphics/sharing-resources-between-directx-and-opengl/WGL_NV_DX_interop_demo.zip">WGL_NV_DX_interop_demo.zip</a></p>

<p></p>

<p>Generally speaking it would be advantageous to share resources (particularly surface data) between both applications. This can be achieved many ways with varying degrees of performance. However the ideal scenario would be to load only a single copy of the texture data into graphics memory, and sample from that same texture data using both DX and OGL calls at the same time. Fortunately there is an OpenGL extension to do exactly this, called <a href="https://www.khronos.org/registry/OpenGL/extensions/NV/WGL_NV_DX_interop.txt">WGL_NV_DX_interop</a> for DX9, and <a href="https://www.khronos.org/registry/OpenGL/extensions/NV/WGL_NV_DX_interop2.txt">WGL_NV_DX_interop2</a> for DX10+.</p>

<p>This extension has historically had spotty hardware vendor support. It was initially proposed by Nvidia and support was later added to AMD graphics drivers. With the latest drivers for Intel&rsquo;s current chips (HD Graphics 4200+), compatibility for this extension has been added. I&rsquo;ve tested this code on an Intel HD 4400, AMD 6950, and Nvidia GTX 570. One major caveat is that I have not been able to successfully present a shared render target that is simultaneously being sampled, even with the synchronization objects available in the extension. The render target will be updated, and the sample will happen correctly, but some unknown limitation prevents the original render target from being presented. The code samples below perform a GPU copy from video memory to video memory in order to present both the DX and GL rendered results. This GPU copy is significantly faster than any CPU copy (e.g. memcpy), and is only possible through this sharing extension. However, an ideal implementation should be able to avoid this copy.</p>

<p>Let&rsquo;s look at the special considerations for initializing DX and OGL. This demo uses DX9, however DX10+ support should also be available (I have not personally tested this). For DX9, it is important that a D3D9EX device is used (instead of a D3D9 device). D3D9EX is available in Windows 7+ and adds a new more efficient flip mode; but more importantly it enables the creation of shared resources. These resources are indicated by the handles returned by <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb174358(v=vs.85).aspx">CreateOffscreenPlainSurface</a> or <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb174363(v=vs.85).aspx">CreateTexture</a>. In the code below, CreateOffscreenPlainSurface in InitDX() will generate a shared handle, that is later registered in InitGL() using the extension function wglDXSetResourceShareHandleNV. This is what makes the GL renderer aware of the DX resource. This handle represents the GPU video memory that backs the respective DX/GL textures. In this demo, the DX renderer&rsquo;s shared texture is called g_pSharedSurface and it&rsquo;s handle is called g_hSharedSurface, while the GL renderer&rsquo;s texture is called g_GLTexture and the corresponding handle is called g_hGLSharedTexture. Before registering the shared resource with GL, the DX device must be associated using wglDXOpenDeviceNV.</p>
<div class="highlight"><pre class="chroma">void InitDX(HWND hWndDX)
{
    D3DPRESENT_PARAMETERS d3dpp;

    ZeroMemory(&amp;d3dpp, sizeof(d3dpp));
    d3dpp.Windowed = TRUE;
    d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow = hWndDX;
    d3dpp.BackBufferFormat = D3DFMT_X8R8G8B8;

    HRESULT hr = S_OK;

    // A D3D9EX device is required to create the g_hSharedSurface
    Direct3DCreate9Ex(D3D_SDK_VERSION, &amp;g_pD3d);

    // The interop definition states D3DCREATE_MULTITHREADED is required, but it may vary by vendor
    hr = g_pD3d-&gt;CreateDeviceEx(D3DADAPTER_DEFAULT,
                      D3DDEVTYPE_HAL,
                      hWndDX,
                      D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_MULTITHREADED,
                      &amp;d3dpp,
                      NULL,
                      &amp;g_pDevice);

    hr = g_pDevice-&gt;GetRenderTarget(, &amp;g_pSurfaceRenderTarget);
    D3DSURFACE_DESC rtDesc;
    g_pSurfaceRenderTarget-&gt;GetDesc(&amp;rtDesc);

    // g_pSharedSurface should be able to be opened in OGL via the WGL_NV_DX_interop extension
    // Vendor support for various textures/surfaces may vary
    hr = g_pDevice-&gt;CreateOffscreenPlainSurface(rtDesc.Width,
                                                rtDesc.Height,
                                                rtDesc.Format,
                                                D3DPOOL_DEFAULT,
                                                &amp;g_pSharedSurface,
                                                &amp;g_hSharedSurface);

    hr = g_pDevice-&gt;SetRenderState(D3DRS_LIGHTING, FALSE);
    hr = g_pDevice-&gt;SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);


    CUSTOMVERTEX vertices[] =
    {
        {  2.0f, -2.0f, 0.0f, D3DCOLOR_XRGB(, , 255)},
        {  0.0f,  2.0f, 0.0f, D3DCOLOR_XRGB(, 255, )},
        { -2.0f, -2.0f, 0.0f, D3DCOLOR_XRGB(255, , )},
    };

    hr = g_pDevice-&gt;CreateVertexBuffer(9*sizeof(CUSTOMVERTEX),
                                       ,
                                       CUSTOMFVF,
                                       D3DPOOL_DEFAULT,
                                       &amp;g_pVB,
                                       NULL);

    VOID* pVoid;
    hr = g_pVB-&gt;Lock(, , (void**)&amp;pVoid, );
    memcpy(pVoid, vertices, sizeof(vertices));
    hr = g_pVB-&gt;Unlock();
}</pre></div><div class="highlight"><pre class="chroma">void InitGL(HWND hWndGL)
{
    static  PIXELFORMATDESCRIPTOR pfd=
    {
        sizeof(PIXELFORMATDESCRIPTOR),              // Size Of This Pixel Format Descriptor
        1,                                          // Version Number
        PFD_DRAW_TO_WINDOW |                        // Format Must Support Window
        PFD_SUPPORT_OPENGL |                        // Format Must Support OpenGL
        PFD_DOUBLEBUFFER,                           // Must Support Double Buffering
        PFD_TYPE_RGBA,                              // Request An RGBA Format
        32,                                         // Select Our Color Depth
        , , , , , ,                           // Color Bits Ignored
        ,                                          // No Alpha Buffer
        ,                                          // Shift Bit Ignored
        ,                                          // No Accumulation Buffer
        , , , ,                                 // Accumulation Bits Ignored
        16,                                         // 16Bit Z-Buffer (Depth Buffer)  
        ,                                          // No Stencil Buffer
        ,                                          // No Auxiliary Buffer
        PFD_MAIN_PLANE,                             // Main Drawing Layer
        ,                                          // Reserved
        , ,                                     // Layer Masks Ignored
    };
   
    g_hDCGL = GetDC(hWndGL);
    GLuint PixelFormat = ChoosePixelFormat(g_hDCGL, &amp;pfd);
    SetPixelFormat(g_hDCGL, PixelFormat, &amp;pfd);
    HGLRC hRC = wglCreateContext(g_hDCGL);
    wglMakeCurrent(g_hDCGL, hRC);

    GLenum x = glewInit();

    // Register the shared DX texture with OGL
    if (WGLEW_NV_DX_interop)
    {
        // Acquire a handle to the D3D device for use in OGL
        g_hDX9Device = wglDXOpenDeviceNV(g_pDevice);

        if (g_hDX9Device)
        {
            glGenTextures(1, &amp;g_GLTexture);

            // This registers a resource that was created as shared in DX with its shared handle
            bool success = wglDXSetResourceShareHandleNV(g_pSharedSurface, g_hSharedSurface);

            // g_hGLSharedTexture is the shared texture data, now identified by the g_GLTexture name
            g_hGLSharedTexture = wglDXRegisterObjectNV(g_hDX9Device,
                                                       g_pSharedSurface,
                                                       g_GLTexture,
                                                       GL_TEXTURE_2D,
                                                       WGL_ACCESS_READ_ONLY_NV);
        }
    }

    glViewport(, , SCREEN_WIDTH, SCREEN_HEIGHT);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(, SCREEN_WIDTH, SCREEN_HEIGHT, , -1, 1);
    glDisable(GL_DEPTH_TEST);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}</pre></div>
<p>After the textures are created as shared surfaces and these surfaces are registered with the GL renderer, we can begin rendering. The most important consideration here is proper synchronization of reads/writes of the shared surface between the two renderers. This example shows the DX renderer writing a triangle to a render target, which is then copied to the shared surface, and the GL renderer reading from that shared surface and texturing a quad with it. Because of the potential read-after-write hazards, it is necessary for the GL renderer to acquire a lock on the shared surface via wglDXLockObjectsNV. This lock does not result in the surface being copied to CPU space (as would happen with a normal DX9 <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb205913(v=vs.85).aspx">Lock</a> operation. Instead, this lock triggers the GPU to perform the necessary flushing and stalling to guarantee that the surface has finished being written to before reading from it. This is necessary even if the DX and GL renderers operate sequentially (i.e. not multi-threaded), because the rendering commands scheduled on the GPU execute asynchronously.</p>
<div class="highlight"><pre class="chroma">void RenderDX(void)
{    
    // Set up transformations
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH(&amp;matView,
                       &amp;D3DXVECTOR3 (0.0f, 0.0f, -10.0f),
                       &amp;D3DXVECTOR3 (0.0f, 0.0f, 0.0f),
                       &amp;D3DXVECTOR3 (0.0f, 1.0f, 0.0f));
    g_pDevice-&gt;SetTransform(D3DTS_VIEW, &amp;matView);

    D3DXMATRIX matProjection;
    D3DXMatrixPerspectiveFovLH(&amp;matProjection,
                               D3DXToRadian(45),
                               (FLOAT)SCREEN_WIDTH / (FLOAT)SCREEN_HEIGHT,
                               1.0f,
                               25.0f);
    g_pDevice-&gt;SetTransform(D3DTS_PROJECTION, &amp;matProjection);

    D3DXMATRIX matTranslate;
    D3DXMatrixTranslation(&amp;matTranslate, 0.0f, 0.0f, 0.0f);

    D3DXMATRIX matRotate;
    static float rot = ;
    rot+=0.01;
    D3DXMatrixRotationZ(&amp;matRotate, rot);

    D3DXMATRIX matTransform = matRotate * matTranslate;

    HRESULT hr = S_OK;
    hr = g_pDevice-&gt;Clear(, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(40, 40, 60), 1.0f, );

    // Draw a spinning triangle
    hr = g_pDevice-&gt;BeginScene();

    hr = g_pDevice-&gt;SetStreamSource(, g_pVB, , sizeof(CUSTOMVERTEX));
    hr = g_pDevice-&gt;SetFVF(CUSTOMFVF);
    hr = g_pDevice-&gt;SetTransform(D3DTS_WORLD, &amp;matTransform);
    hr = g_pDevice-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, , 1);

    // Copy the render target to the shared surface
    // StretchRect between two D3DPOOL_DEFAULT surfaces will be a GPU Blt.
    // Note that GetRenderTargetData() cannot be used because it is intended to copy from GPU to CPU.
    hr = g_pDevice-&gt;StretchRect(g_pSurfaceRenderTarget, NULL, g_pSharedSurface, NULL, D3DTEXF_NONE);
    hr = g_pDevice-&gt;EndScene();
    hr = g_pDevice-&gt;Present(NULL, NULL, NULL, NULL);
}</pre></div><div class="highlight"><pre class="chroma">void RenderGL(void)
{
    glClearColor(0.0, 0.0, 0.0, 1.0);
    glClear(GL_COLOR_BUFFER_BIT);

    // Lock the shared surface
    wglDXLockObjectsNV(g_hDX9Device, 1, &amp;g_hGLSharedTexture);

    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, g_GLTexture);

    glPushMatrix();
    glBegin(GL_QUADS);

    glTexCoord2d(0.0, 0.0); glVertex2f(         0.0f,           .f);
    glTexCoord2d(0.0, 1.0); glVertex2f(         0.0f, SCREEN_HEIGHT);
    glTexCoord2d(1.0, 1.0); glVertex2f( SCREEN_WIDTH, SCREEN_HEIGHT);
    glTexCoord2d(1.0, 0.0); glVertex2f( SCREEN_WIDTH,          0.0f);

    glEnd();
    glPopMatrix();

    SwapBuffers(g_hDCGL);

    // Unlock the shared surface
    wglDXUnlockObjectsNV(g_hDX9Device, 1, &amp;g_hGLSharedTexture);
}</pre></div>
<p>The final tear down step is extremely straight forward. The call to wglDXUnregisterObjectNV will disassociate the shared resource with GL, and wglDXCloseDeviceNV will close the device that created the shared surface.</p>
<div class="highlight"><pre class="chroma">void Destroy(void)
{
    if (WGLEW_NV_DX_interop)
    {
        if (g_hGLSharedTexture)
            wglDXUnregisterObjectNV(g_hDX9Device, g_hGLSharedTexture);
        if (g_hDX9Device)
            wglDXCloseDeviceNV(g_hDX9Device);
    }

    if (g_pSysmemSurface)
        g_pSysmemSurface-&gt;Release();
    if (g_pSharedSurface)
        g_pSharedSurface-&gt;Release();
    if (g_pSharedTexture)
        g_pSharedTexture-&gt;Release();
    if (g_pSurfaceRenderTarget)
        g_pSurfaceRenderTarget-&gt;Release();
    if (g_pVB)
        g_pVB-&gt;Release();
    if (g_pDevice)
        g_pDevice-&gt;Release();
    if (g_pD3d)
        g_pD3d-&gt;Release();
}</pre></div>

        
          <div class="blog-tags">
            
              <a href="https://halogenica.github.io/tags/graphics/">Graphics</a>&nbsp;
            
              <a href="https://halogenica.github.io/tags/directx/">DirectX</a>&nbsp;
            
              <a href="https://halogenica.github.io/tags/opengl/">OpenGL</a>&nbsp;
            
          </div>
        

        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://halogenica.github.io/graphics/signed-distance-fields/" data-toggle="tooltip" data-placement="top" title="Signed Distance Fields – Part 1">&larr; Previous Post</a>
            </li>
          
          
        </ul>
      


      
        
        
      

    </div>
  </div>
</div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
              <li>
                <a href="mailto:mike@halogenica.net" title="Email me">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://github.com/halogenica" title="GitHub">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://twitter.com/halogenica" title="Twitter">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://reddit.com/u/halogenica" title="Reddit">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-reddit-alien fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://linkedin.com/in/halogenica" title="LinkedIn">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://www.youtube.com/user/angelkatalyst" title="Youtube">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-youtube fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://itch.io/profile/halogenica" title="Itch.io">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-gamepad fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
          <li>
            
            <a href="https://halogenica.github.io/index.xml" title="RSS">
            
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              Michael Romero
            
          

          &nbsp;&bull;&nbsp;
          2015

          
            &nbsp;&bull;&nbsp;
            <a href="https://halogenica.github.io">Halogenica</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.48</a> powered &nbsp;&bull;&nbsp; Theme by <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a> adapted to <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js" integrity="sha384-/y1Nn9+QQAipbNQWU65krzJralCnuOasHncUFXGkdwntGeSvQicrYkiUBwsgUqc1" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/contrib/auto-render.min.js" integrity="sha384-dq1/gEHSxPZQ7DdrM82ID4YVol9BYyU7GbWlIwnwyPzotpoc57wDw/guX8EaYGPx" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://halogenica.github.io/js/main.js"></script>
<script src="https://halogenica.github.io/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> $(document).ready(function() {$("pre.chroma").css("padding","0");}); </script><script> renderMathInElement(document.body); </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script>
<script src="https://halogenica.github.io/js/load-photoswipe.js"></script>






  </body>
</html>

